<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/success.png">
  <link rel="icon" type="image/png" href="/img/success.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Kehan Xue">
  <meta name="keywords" content="">
  <title>Cartographer Laser-SLAM 算法流程解析与调优 - Kehan&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kehan's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/black-bg.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2019-12-07 16:09">
      December 7, 2019 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      72
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>本篇博客的目的是记录自己在实物机器人上调试 Cartographer 算法的过程中，参考的资料和结合部分代码，一些自己总结的内容。Cartographer 是 Google 开源的一个激光 SLAM 项目，有着非常惊艳的工程实现。</p>
<a id="more"></a>
<p>本文参考cartographer<a href="https://google-cartographer-ros.readthedocs.io/en/latest/" target="_blank" rel="noopener">官方文档</a>。</p>
<p>首先要明确的一点，Cartographer的官方文档也提到，这个<strong>简介</strong>仅仅给出直觉概述层面上的Cartographer的不同子系统的介绍和配置说明。如果为了更详细的描述和更严谨的表达，应该去看Cartographer的Paper。虽然Paper中仅仅给出了2D SLAM的重要概念的严格表达，但这些概念可以非常自然的推广到3D。</p>
<p>Paper：</p>
<blockquote>
<p>W. Hess, D. Kohler, H. Rapp, and D. Andor, <a href="https://research.google.com/pubs/pub45466.html" target="_blank" rel="noopener">Real-Time Loop Closure in 2D LIDAR SLAM</a>, in <em>Robotics and Automation (ICRA), 2016 IEEE International Conference on</em>. IEEE, 2016. pp. 1271–1278.</p>
</blockquote>
<h1 id="cartographer-algorithm-walkthrough-for-tuning"><a class="markdownIt-Anchor" href="#cartographer-algorithm-walkthrough-for-tuning"></a> Cartographer Algorithm walkthrough for tuning</h1>
<h2 id="cartographer基本思路简介"><a class="markdownIt-Anchor" href="#cartographer基本思路简介"></a> cartographer基本思路简介</h2>
<p><a href="https://blog.csdn.net/jsgaobiao/article/details/53116042" target="_blank" rel="noopener">这篇</a>CSDN博客说的挺简洁，但是现在必须成VIP才能看的文章了，有点醉…主要两张图如下：</p>
<ol>
<li>
<p>算法的基本思路</p>
<p><img src="assets/20161110144436386.png" srcset="/img/loading.gif" alt="img" /></p>
</li>
<li>
<p>基本的ROS框架如下，当然可以有更多类型的输入，比如里程计信息等。</p>
<p><img src="assets/20161110145019043.png" srcset="/img/loading.gif" alt="img" /></p>
</li>
</ol>
<p>Cartographer它的设计目标是实现低计算资源消耗，实时优化，不追求高精度（可以达到r=5cm级别的精度） Paper中说了，<strong>它主要的贡献并不在算法层面，而是提供了工程上高效率、Robust的代码实现。</strong></p>
<p><img src="assets/high_level_system_overview.png" srcset="/img/loading.gif" alt="Cartographer系统结构图" /></p>
<p>Cartographer可以看做两个独立但有关系的子系统，Local SLAM 和 Global SLAM。</p>
<ul>
<li>
<p>Local SLAM可以被看做是前端(local trajectory builder)，任务是建立一个个的submap。各个submap是本地一致的，但是会慢慢的漂移。Local SLAM相关的配置文件是<a href="https://github.com/googlecartographer/cartographer/blob/df337194e21f98f8c7b0b88dab33f878066d4b56/configuration_files/trajectory_builder_2d.lua" target="_blank" rel="noopener">trajectory_builder_2d.lua</a>或<a href="https://github.com/googlecartographer/cartographer/blob/df337194e21f98f8c7b0b88dab33f878066d4b56/configuration_files/trajectory_builder_3d.lua" target="_blank" rel="noopener">trajectory_builder_3d.lua</a>。后面用<em>TRAJECTORY_BUILDER_nD</em>表示相通的配置options。</p>
</li>
<li>
<p>Golbal SLAM是后端，单开了一个线程运行在后端，主要作用是寻找 loop closure constraints(回环约束)。通过<strong>scans</strong>(gathered in <strong>nodes</strong>) 与submaps进行matching的方法来工作。并且可以结合其他传感器的数据来进一步提高精度，来确定一致性最强的Global optimization 方案。3D SLAM中还会尝试去估计重力方向。相关配置文件是<a href="https://github.com/googlecartographer/cartographer/blob/df337194e21f98f8c7b0b88dab33f878066d4b56/configuration_files/pose_graph.lua" target="_blank" rel="noopener">pose_graph.lua</a>。</p>
</li>
</ul>
<blockquote>
<p>TODO:</p>
<ul>
<li>.lua修改为本地gitlab仓库链接</li>
<li>Global中的scans和nodes的关系？<strong>scans</strong>(gathered in <strong>nodes</strong>)</li>
</ul>
</blockquote>
<p>总的来说，Local SLAM 的主要工作是生成更好的 submaps，Global SLAM的工作是将这些 submaps 更好的结合起来。</p>
<h2 id="input-process"><a class="markdownIt-Anchor" href="#input-process"></a> Input Process</h2>
<h3 id="laser-data"><a class="markdownIt-Anchor" href="#laser-data"></a> Laser Data</h3>
<blockquote>
<p>注意！Cartographer中关于距离的参数的单位均为<strong>米/m</strong></p>
</blockquote>
<p>由于在实际运用的过程中，雷达在机器人身上的安装位置导致雷达被机器人身上其他部件挡了、或者雷达自身落灰了，或者一些从不期望的来源得到的最远的测量值（比如反射、或者自身传感器噪声）等，都是SLAM过程中所不期望的。对于这些噪声，Cartographer starts by applying a bandpass filter and only keeps range values between a certain min and max range。下面的这俩值根据你机器人和雷达的实际情况来确定。</p>
<p>这两个参数就是雷达扫描数据的距离范围。参数为下面两个。</p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_nD.min_range
TRAJECTORY_BUILDER_nD.max_range</code></pre>
<p>Cartographer会用<code>TRAJECTORY_BUILDER_2D.missing_data_ray_length</code>的值来替换实际大于 <code>TRAJECTORY_BUILDER_nD.max_range</code> 的ranges。</p>
<blockquote>
<p>TODO:</p>
<ul>
<li>
<p>考虑根据具体的自己机器人的形状和雷达的实际效果，确定更好的卡值的方法？但又仔细一想好像又没这必要。</p>
</li>
<li>
<p><code>TRAJECTORY_BUILDER_2D.missing_data_ray_length</code>参数的说法还是有点迷…代码中是这样写的:</p>
<p><code>cartographer/mapping/internal/2d/local_trajectory_builder_2d.h</code> line: 170-189</p>
<pre><code class="hljs c++"><span class="hljs-comment">// Drop any returns below the minimum range and convert returns beyond the</span>
<span class="hljs-comment">// maximum range into misses.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; synchronized_data.ranges.<span class="hljs-built_in">size</span>(); ++i) &#123;
  <span class="hljs-keyword">const</span> Eigen::Vector4f&amp; hit = synchronized_data.ranges[i].point_time;
  <span class="hljs-keyword">const</span> Eigen::Vector3f origin_in_local =
      range_data_poses[i] *
      synchronized_data.origins.at(synchronized_data.ranges[i].origin_index);
  <span class="hljs-keyword">const</span> Eigen::Vector3f hit_in_local = range_data_poses[i] * hit.head&lt;<span class="hljs-number">3</span>&gt;();
  <span class="hljs-keyword">const</span> Eigen::Vector3f delta = hit_in_local - origin_in_local;
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> range = delta.norm();
  <span class="hljs-keyword">if</span> (range &gt;= options_.min_range()) &#123;
    <span class="hljs-keyword">if</span> (range &lt;= options_.max_range()) &#123;
      accumulated_range_data_.returns.push_back(hit_in_local);
    &#125; <span class="hljs-keyword">else</span> &#123;
      accumulated_range_data_.misses.push_back(
          origin_in_local +
          options_.missing_data_ray_length() / range * delta);
    &#125;
  &#125;
&#125;</code></pre>
<p>具体待跑起来后分析实际数据</p>
</li>
</ul>
</blockquote>
<p>如果将 3D 雷达用在 2D SLAM的话,提供一个&quot;截断&quot;的参数,就是把一定高度范围内的扫描点映射到 2D 的一个平面上。</p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D.max_z
TRAJECTORY_BUILDER_2D.min_z</code></pre>
<p>一组激光雷达的距离数据是一段时间内测量出来的，而这一段时间内机器人是运动的，这就导致了激光数据会产生畸变。这些距离数据被封装到一帧一帧的ROS message中，每一帧都带有时间戳信息，Cartographer会把多(&gt;=1)帧集合(accumulate)成一个大帧作为算法的输入。Cartographer认为这每一帧都是独立的，以帧为单位补偿运动导致的激光雷达数据产生的畸变，然后再把这些帧集合到一块去。所以当然Cartographer接收到的数据帧的频率越高，Cartographer的补偿效果越好，算法的输入数据质量越高。</p>
<p>所以<code>TRAJECTORY_BUILDER_nD.num_accumulated_range_data</code>参数的意义就是集合多少帧运动补偿后形成算法输入的大数据帧。(该参数要根据实际雷达的数据采集频率和每一帧数据的扫描范围来定，比如Rplidar A3的一帧数据是采样一圈；而VLP-16的一帧数据可以调成一个udp数据包而不是一圈数据，并且这样更好，因为转一圈也是需要时间的，这样就可以把一圈内的数据也做了运动补偿)</p>
<p>相关代码(<code>cartographer/mapping/internal/2d/local_trajectory_builder_2d.h</code> line:142-205)：</p>
<pre><code class="hljs c++"><span class="hljs-keyword">if</span> (num_accumulated_ == <span class="hljs-number">0</span>) &#123;
  accumulation_started_ = <span class="hljs-built_in">std</span>::chrono::steady_clock::now();
&#125;
...
<span class="hljs-keyword">if</span> (num_accumulated_ == <span class="hljs-number">0</span>) &#123;
  <span class="hljs-comment">// 'accumulated_range_data_.origin' is uninitialized until the last</span>
  <span class="hljs-comment">// accumulation.</span>
  accumulated_range_data_ = sensor::RangeData&#123;&#123;&#125;, &#123;&#125;, &#123;&#125;&#125;;
&#125;

<span class="hljs-comment">// Drop any returns below the minimum range and convert returns beyond the</span>
<span class="hljs-comment">// maximum range into misses.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; synchronized_data.ranges.<span class="hljs-built_in">size</span>(); ++i) &#123;
  ...
  <span class="hljs-keyword">if</span> (range &gt;= options_.min_range()) &#123;
    <span class="hljs-keyword">if</span> (range &lt;= options_.max_range()) &#123;
      accumulated_range_data_.returns.push_back(hit_in_local);
    &#125; <span class="hljs-keyword">else</span> &#123;
      accumulated_range_data_.misses.push_back(
          origin_in_local +
          options_.missing_data_ray_length() / range * delta);
    &#125;
  &#125;
&#125;
++num_accumulated_;

<span class="hljs-keyword">if</span> (num_accumulated_ &gt;= options_.num_accumulated_range_data()) &#123;
  num_accumulated_ = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> transform::Rigid3d gravity_alignment = transform::Rigid3d::Rotation(
      extrapolator_-&gt;EstimateGravityOrientation(time));
  <span class="hljs-comment">// TODO(gaschler): This assumes that 'range_data_poses.back()' is at time</span>
  <span class="hljs-comment">// 'time'.</span>
  accumulated_range_data_.origin = range_data_poses.back().translation();
  <span class="hljs-keyword">return</span> AddAccumulatedRangeData(
      time,
      TransformToGravityAlignedFrameAndFilter(
          gravity_alignment.cast&lt;<span class="hljs-keyword">float</span>&gt;() * range_data_poses.back().inverse(),
          accumulated_range_data_),
      gravity_alignment);
&#125;</code></pre>
<h4 id="voxel-filter"><a class="markdownIt-Anchor" href="#voxel-filter"></a> Voxel Filter</h4>
<p>较近的表面(如路面)经常扫描得到更多的points,而远处的物体的points经常比较稀少. 为了降低计算量, 需要对点云数据进行下采样, 简单的随机采样仍然会导致低密度区的点更少,而高密度区的点仍然比较多.因此cartographer 采用 voxel_filter (体素滤波)的方法。通过输入的点云数据创建一个三维体素栅格（可把体素栅格想象为微小的空间三维立方体的集合），然后在每个体素（即，三维立方体）内，用体素中所有点的重心来近似显示体素中其他点，这样该体素就内所有点就用一个重心点最终表示，对于所有体素处理后得到过滤后的点云。<code>TRAJECTORY_BUILDER_nD.voxel_filter_size</code>即为立方体的大小。如果立方体较小的话会导致更密集的数据，所耗的计算量更大。而较大的话可能会导致数据丢失但是计算速度会更快。</p>
<p>在提供了定大小的 voxel_filter, Cartographer还提供了一个 adaptive_voxel_filter,  adaptive_voxel_filter 可以在最大边长<code>TRAJECTORY_BUILDER_nD.*adaptive_voxel_filter.max_length</code>的限制下优化确定voxel_filter_size来实现目标的points数<code>TRAJECTORY_BUILDER_nD.*adaptive_voxel_filter.min_num_points</code> 。</p>
<p>官方给的默认配置：</p>
<p><code>trajectory_builder_2d.lua</code></p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D = &#123;
  ...
  voxel_filter_size = <span class="hljs-number">0.025</span>,

  adaptive_voxel_filter = &#123;
    max_length = <span class="hljs-number">0.5</span>,
    min_num_points = <span class="hljs-number">200</span>,
    max_range = <span class="hljs-number">50.</span>,
  &#125;,
  ...
&#125;</code></pre>
<p><code>trajectory_builder_3d.lua</code></p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_3D = &#123;
  ...  
  voxel_filter_size = <span class="hljs-number">0.15</span>,

  high_resolution_adaptive_voxel_filter = &#123;
    max_length = <span class="hljs-number">2.</span>,
    min_num_points = <span class="hljs-number">150</span>,
    max_range = <span class="hljs-number">15.</span>,
  &#125;,

  low_resolution_adaptive_voxel_filter = &#123;
    max_length = <span class="hljs-number">4.</span>,
    min_num_points = <span class="hljs-number">200</span>,
    max_range = MAX_3D_RANGE,
  &#125;,
  ...
&#125;</code></pre>
<h3 id="imu-data"><a class="markdownIt-Anchor" href="#imu-data"></a> IMU Data</h3>
<p>IMU对于SLAM可以提供非常有用的信息，Cartographer 直接利用IMU所提供的三轴线加速度与角速度信息，可以提供一个较为精确的重力方向，以及提供带有噪声但是整体方向大概正确的关于机器人旋转的信息。为了滤掉IMU的噪声，gravity is observed over a certain amount of time。在2D SLAM 中，可以做到无外界的一些补充信息来源而实时处理数据，所以 2D SLAM 可以选择是否使用 IMU 的消息。但是在 3D SLAM 中需要提供 IMU 数据作判断scans方向的先验，可以大大降低 scan 匹配的复杂性。</p>
<blockquote>
<p>cartographer中关于时间的参数单位均为s(秒).</p>
</blockquote>
<pre><code class="hljs ini"><span class="hljs-attr">TRAJECTORY_BUILDER_nD.use_imu_data</span> = <span class="hljs-literal">true</span>
<span class="hljs-attr">TRAJECTORY_BUILDER_nD.imu_gravity_time_constant</span> = <span class="hljs-number">10.0</span></code></pre>
<p>下文 imu 数据还在 Global optimization 中的应用.</p>
<h2 id="local-slam"><a class="markdownIt-Anchor" href="#local-slam"></a> Local SLAM</h2>
<p>Once a scan has been assembled and filtered from multiple range data, it is ready for the local SLAM algorithm. Local SLAM可以利用来自与pose extrapolator的输出信息作为一个先验，把一帧新的scans通过scan matching的方法插入到当下的submap中。使用pose extrapolator的idea是，通过除了激光雷达以外的传感器的数据来预测当前scan插入到submap的位置，比如里程计信息、IMU等。</p>
<h3 id="two-scan-matching-strategies"><a class="markdownIt-Anchor" href="#two-scan-matching-strategies"></a> Two scan matching strategies</h3>
<h4 id="ceresscanmatcher-以及-realtimecorrelativescanmatcher"><a class="markdownIt-Anchor" href="#ceresscanmatcher-以及-realtimecorrelativescanmatcher"></a> CeresScanMatcher 以及 RealTimeCorrelativeScanMatcher</h4>
<ul>
<li>
<p>CeresScanMatcher 利用上面说的先验 initial guess ,寻找 scan 与当前的 submap 最匹配的位置。通过对 submap 进行插值然后与 scan 进行对齐（It does this by interpolating the submap and sub-pixel aligning the scan）。这种做法比较快速，但是无法修复远大于子图分辨率的误差。如果你的传感器的设置与累积的那个时间区间都是合理的话,仅仅使用 CeresScanMatcher 通常是最好的选择。</p>
<p>CeresScanMatcher 可以为每一个输入源配置一个权重weight，权重就是对其数据的信任度，可以把它视为静态协方差。这个weight是无量纲的，并且是不能相互比较的。weight越大，Cartographer在进行scan matching的时候就对他更关注。数据来源可以包括 occupied space (points from the scan), translation and rotation from the pose extrapolator (or <code>RealTimeCorrelativeScanMatcher</code>)</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">TRAJECTORY_BUILDER_3D</span><span class="hljs-selector-class">.ceres_scan_matcher</span><span class="hljs-selector-class">.occupied_space_weight</span>
<span class="hljs-selector-tag">TRAJECTORY_BUILDER_3D</span><span class="hljs-selector-class">.ceres_scan_matcher</span><span class="hljs-selector-class">.occupied_space_weight_0</span>
<span class="hljs-selector-tag">TRAJECTORY_BUILDER_3D</span><span class="hljs-selector-class">.ceres_scan_matcher</span><span class="hljs-selector-class">.occupied_space_weight_1</span>
<span class="hljs-selector-tag">TRAJECTORY_BUILDER_nD</span><span class="hljs-selector-class">.ceres_scan_matcher</span><span class="hljs-selector-class">.translation_weight</span>
<span class="hljs-selector-tag">TRAJECTORY_BUILDER_nD</span><span class="hljs-selector-class">.ceres_scan_matcher</span><span class="hljs-selector-class">.rotation_weight</span></code></pre>
<p>In 3D, the <code>occupied_space_weight_0</code> and <code>occupied_space_weight_1</code> parameters are related, respectively, to the high resolution and low resolution filtered point clouds.</p>
<p>CeresScanMatcher的名字来源于<a href="http://ceres-solver.org/" target="_blank" rel="noopener">Ceres Solver</a>。这个scan matching问题被建模为一个最小二乘问题，两帧间的motion是待优化变量。（GN等方法）Ceres optimizes the motion using a descent algorithm for a given number of iterations. Ceres can be configured to adapt the convergence speed to your own needs.</p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_nD.ceres_scan_matcher.ceres_solver_options.use_nonmonotonic_steps
TRAJECTORY_BUILDER_nD.ceres_scan_matcher.ceres_solver_options.max_num_iterations
TRAJECTORY_BUILDER_nD.ceres_scan_matcher.ceres_solver_options.num_threads</code></pre>
<p><code>use_nonmonotonic_steps</code>这个暂时还未深究，参见<a href="http://ceres-solver.org/nnls_solving.html#non-monotonic-steps" target="_blank" rel="noopener">Ceres-Solver官方文档讲解</a></p>
<p>官方给的默认配置：</p>
<p><code>trajectory_builder_2d.lua</code></p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D = &#123;
  ...
  ceres_scan_matcher = &#123;
    occupied_space_weight = <span class="hljs-number">1.</span>,
    translation_weight = <span class="hljs-number">10.</span>,
    rotation_weight = <span class="hljs-number">40.</span>,
    ceres_solver_options = &#123;
      use_nonmonotonic_steps = <span class="hljs-literal">false</span>,
      max_num_iterations = <span class="hljs-number">20</span>,
      num_threads = <span class="hljs-number">1</span>,
    &#125;,
  &#125;,
  ...
&#125;</code></pre>
</li>
<li>
<p>RealTimeCorrelativeScanMatcher 在你比较不信任你的其他传感器或者不存在其他的传感器的情况下可以启用。它的做法类似于回环检测中的做法将 scan 与当前 submap 进行 match。Best match 然后被用作 CeresScanMatcher 的先验。这种 match 的方式对计算资源要求较高，并且开了后，就忽略了其他传感器的数据。但这种做法在 feature rich 的环境中的鲁棒性非常好。</p>
<p>同样 RealTimeCorrelativeScanMatcher 也可以根据对 sensors 的信任度进行配置(即可以配置不同权重/置信度/weight)。它的工作原理是在一个搜索窗口中(搜索窗口的大小由搜索的最大距离半径和角度范围来指定)。在此窗口中进行 scan match 的时候,可以为 translation 和 rotation 选择不同的权重。</p>
<blockquote>
<p><em>TODO</em></p>
<p><em>例如当已知机器人不会旋转过多的话,就可以改变对应 weight。</em></p>
<p><em>所以这个weight到底是指？具体还是看代码吧</em></p>
</blockquote>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_nD.use_online_correlative_scan_matching
TRAJECTORY_BUILDER_nD.real_time_correlative_scan_matcher.linear_search_window
TRAJECTORY_BUILDER_nD.real_time_correlative_scan_matcher.angular_search_window
TRAJECTORY_BUILDER_nD.real_time_correlative_scan_matcher.translation_delta_cost_weight
TRAJECTORY_BUILDER_nD.real_time_correlative_scan_matcher.rotation_delta_cost_weight</code></pre>
<p>官方给的默认配置：</p>
<p><code>trajectory_builder_2d.lua</code></p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D = &#123;
  ...
  use_online_correlative_scan_matching = <span class="hljs-literal">false</span>,
  real_time_correlative_scan_matcher = &#123;
    linear_search_window = <span class="hljs-number">0.1</span>,
    angular_search_window = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">rad</span>(<span class="hljs-number">20.</span>),
    translation_delta_cost_weight = <span class="hljs-number">1e-1</span>,
    rotation_delta_cost_weight = <span class="hljs-number">1e-1</span>,
  &#125;,
  ...
&#125;</code></pre>
</li>
</ul>
<h3 id="motion_filter"><a class="markdownIt-Anchor" href="#motion_filter"></a> motion_filter</h3>
<p>为避免将过多的 scan 插入到 submap 里，当两个 scan 成功 match 后，会得到两个 match 之间的运动关系。当两者运动关系不明显的话,这个 match 结果就不会被插入到 submap 中去。这个操作通过运动滤波器中卡time,distance以及angle的阈值来实现。</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">TRAJECTORY_BUILDER_nD</span><span class="hljs-selector-class">.motion_filter</span><span class="hljs-selector-class">.max_time_seconds</span>
<span class="hljs-selector-tag">TRAJECTORY_BUILDER_nD</span><span class="hljs-selector-class">.motion_filter</span><span class="hljs-selector-class">.max_distance_meters</span>
<span class="hljs-selector-tag">TRAJECTORY_BUILDER_nD</span><span class="hljs-selector-class">.motion_filter</span><span class="hljs-selector-class">.max_angle_radians</span></code></pre>
<p>官方给的默认配置：</p>
<p><code>trajectory_builder_2d.lua</code></p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D = &#123;
  ...
  motion_filter = &#123;
    max_time_seconds = <span class="hljs-number">5.</span>,
    max_distance_meters = <span class="hljs-number">0.2</span>,
    max_angle_radians = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">rad</span>(<span class="hljs-number">1.</span>),
  &#125;,
  ...
&#125;</code></pre>
<h3 id="submap"><a class="markdownIt-Anchor" href="#submap"></a> Submap</h3>
<p>当Local SLAM接收到一定数量的range data时可认为此时当前的submap被完成了，这个即由<code>TRAJECTORY_BUILDER_nD.submaps.num_range_data</code>参数来指定。Local SLAM的结果在时间上积累后会产生漂移误差，Global SLAM可以来fix这个误差。这个Submap必须足够的小从而可以认为它是局部正确的。但从另一方面来看，他又必须足够的大从而可以做回环。</p>
<pre><code class="hljs css"><span class="hljs-selector-tag">TRAJECTORY_BUILDER_nD</span><span class="hljs-selector-class">.submaps</span><span class="hljs-selector-class">.num_range_data</span></code></pre>
<p>这里总结一下，雷达数据到建图的流程如下：</p>
<p><img src="assets/CartographerLaserData-1575206288976.png" srcset="/img/loading.gif" alt="CartographerLaserData" /></p>
<p>Submap 可以采用不止一种的数据结构来存储。但是现在大多都是采用的概率栅格地图（probability grids）的方式来存储。但是在2D中，还可以采用TSDF（Truncated Signed Distance Fields）地图类型。</p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D.submaps.grid_options_2d.grid_type</code></pre>
<p>概率栅格地图的资料很多，去搜一下即可。这里就贴文档原句了。Odds are updated according to “<em>hits</em>” (where the range data is measured) and “<em>misses</em>” (the free space between the sensor and the measured points)。可以根据对被占据occupied和free space的雷达数据的置信度，加减hits和misses的weight值（Both <em>hits</em> and <em>misses</em> can have a different weight in occupancy probability calculations giving more or less trust to occupied or free space measurements）。</p>
<blockquote>
<p><em>TODO</em></p>
<p><em>这里为啥分了两个…是因为不同的地图类型吗</em></p>
</blockquote>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D.submaps.range_data_inserter.probability_grid_range_data_inserter.hit_probability
TRAJECTORY_BUILDER_2D.submaps.range_data_inserter.probability_grid_range_data_inserter.miss_probability
TRAJECTORY_BUILDER_3D.submaps.range_data_inserter.hit_probability
TRAJECTORY_BUILDER_3D.submaps.range_data_inserter.miss_probability</code></pre>
<p>官方给的默认配置：</p>
<p><code>trajectory_builder_2d.lua</code></p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D = &#123;
  ...
  submaps = &#123;
    num_range_data = <span class="hljs-number">90</span>,
    grid_options_2d = &#123;
      grid_type = <span class="hljs-string">"PROBABILITY_GRID"</span>,
      resolution = <span class="hljs-number">0.05</span>,
    &#125;,
    range_data_inserter = &#123;
      range_data_inserter_type = <span class="hljs-string">"PROBABILITY_GRID_INSERTER_2D"</span>,
      probability_grid_range_data_inserter = &#123;
        insert_free_space = <span class="hljs-literal">true</span>,
        hit_probability = <span class="hljs-number">0.55</span>,
        miss_probability = <span class="hljs-number">0.49</span>,
      &#125;,
    &#125;,
  &#125;,
  ...
&#125;</code></pre>
<p>2D SLAM中一个submap仅有一个栅格地图（probability grid）被存储。在3D SLAM中因为scan matching性能的原因，维护了两个<em>hybrid</em> probability grid (the term “hybrid” only refers to an internal tree-like data representation and is abstracted to the user)，并分别应用了一个adaptive_voxel_filter。：</p>
<ul>
<li>一个是用于远距离测量的低分辨率 hybrid grid</li>
<li>另一个是用于近距离测量的高分辨率 hybrid grid</li>
</ul>
<p>Scan match 首先将远处的低分辨率的点云与低分辨率 hybrid grid 对齐，然后通过高分辨率的近处点云与高分辨率的hybrid grid对齐来refine pose。</p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_2D.submaps.grid_options_2d.resolution
TRAJECTORY_BUILDER_3D.submaps.high_resolution
TRAJECTORY_BUILDER_3D.submaps.low_resolution
TRAJECTORY_BUILDER_3D.high_resolution_adaptive_voxel_filter.max_range
TRAJECTORY_BUILDER_3D.low_resolution_adaptive_voxel_filter.max_range</code></pre>
<blockquote>
<p><em>TODO</em></p>
<p><em>上面的adaptive_voxel_filter.max_range是指的近和远的距离的界定吗</em></p>
</blockquote>
<p>Cartographer ROS提供了一个可以在rviz中可视化submaps的插件。可以选择submap通过他们的id。3D SLAM中rviz仅仅显示3D hybrid probability grids的2D 投影（in grayscale）。通过Rviz左侧栏可以切换high resolution hybrid grids来看。</p>
<p><code>trajectory_builder_3d.lua</code></p>
<pre><code class="hljs lua">TRAJECTORY_BUILDER_3D = &#123;
  ...
  submaps = &#123;
    high_resolution = <span class="hljs-number">0.10</span>,
    high_resolution_max_range = <span class="hljs-number">20.</span>,
    low_resolution = <span class="hljs-number">0.45</span>,
    num_range_data = <span class="hljs-number">160</span>,
    range_data_inserter = &#123;
      hit_probability = <span class="hljs-number">0.55</span>,
      miss_probability = <span class="hljs-number">0.49</span>,
      num_free_space_voxels = <span class="hljs-number">2</span>,
    &#125;,
  &#125;,
  ...
&#125;</code></pre>
<h2 id="global-slam"><a class="markdownIt-Anchor" href="#global-slam"></a> Global SLAM</h2>
<p>当Local SLAM成功生成submaps的同时，在后端运行着一个全局的优化程序（sparse pose adjustment）。通过调整submap的位置来保持全局一致。然后还会考虑回环优化。</p>
<p>每当<code>POSE_GRAPH.optimize_every_n_nodes</code>数目的node被插入地图的时候运行一次optimization。</p>
<p>通常先将<code>POSE_GRAPH.optimize_every_n_nodes</code> 置零来关闭Global SLAM，然后专心的来调Local SLAM。这通常是调试Cartographer的第一步。</p>
<p>我们把估计出来的一个Scan的绝对位姿称为trajectory上的一个节点(Node)，那么节点与节点的彼此之间的相对位姿就可以称为一个约束(Constraint)。<a href="https://zhuanlan.zhihu.com/p/50055546" target="_blank" rel="noopener">参考链接</a></p>
<blockquote>
<p>上面的说法的确比较容易理解，并且做Pose Graph的确仅依赖与位姿。但是通过代码来看，这个Node所带的信息不止有Scan的绝对位姿（gravity aligned，用代码中的注释：Transform to approximately gravity align the tracking frame as determined by local SLAM.），还带有gravity aligned的PointCloud。</p>
<p>trajectory_node_data.proto文件：</p>
<pre><code class="hljs protobuf">syntax = <span class="hljs-string">"proto3"</span>;

<span class="hljs-keyword">package</span> cartographer.mapping.proto;

<span class="hljs-keyword">import</span> <span class="hljs-string">"cartographer/sensor/proto/sensor.proto"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">"cartographer/transform/proto/transform.proto"</span>;

<span class="hljs-comment">// Serialized state of a mapping::TrajectoryNode::Data.</span>
<span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">TrajectoryNodeData</span> </span>&#123;
  <span class="hljs-built_in">int64</span> timestamp = <span class="hljs-number">1</span>;
  transform.proto.Quaterniond gravity_alignment = <span class="hljs-number">2</span>;
  sensor.proto.CompressedPointCloud
      filtered_gravity_aligned_point_cloud = <span class="hljs-number">3</span>;
  sensor.proto.CompressedPointCloud high_resolution_point_cloud = <span class="hljs-number">4</span>;
  sensor.proto.CompressedPointCloud low_resolution_point_cloud = <span class="hljs-number">5</span>;
  <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">float</span> rotational_scan_matcher_histogram = <span class="hljs-number">6</span>;
  transform.proto.Rigid3d local_pose = <span class="hljs-number">7</span>;
&#125;
</code></pre>
<p>cartographer/mapping/trajectory_node.h文件：</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrajectoryNode</span> &#123;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> &#123;</span>
    common::Time time;

    <span class="hljs-comment">// Transform to approximately gravity align the tracking frame as</span>
    <span class="hljs-comment">// determined by local SLAM.</span>
    Eigen::Quaterniond gravity_alignment;

    <span class="hljs-comment">// Used for loop closure in 2D: voxel filtered returns in the</span>
    <span class="hljs-comment">// 'gravity_alignment' frame.</span>
    sensor::PointCloud filtered_gravity_aligned_point_cloud;

    <span class="hljs-comment">// Used for loop closure in 3D.</span>
    sensor::PointCloud high_resolution_point_cloud;
    sensor::PointCloud low_resolution_point_cloud;
    Eigen::VectorXf rotational_scan_matcher_histogram;

    <span class="hljs-comment">// The node pose in the local SLAM frame.</span>
    transform::Rigid3d local_pose;
  &#125;;

  <span class="hljs-function">common::Time <span class="hljs-title">time</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> constant_data-&gt;time; &#125;

  <span class="hljs-comment">// This must be a shared_ptr. If the data is used for visualization while the</span>
  <span class="hljs-comment">// node is being trimmed, it must survive until all use finishes.</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">const</span> Data&gt; constant_data;

  <span class="hljs-comment">// The node pose in the global SLAM frame.</span>
  transform::Rigid3d global_pose;
&#125;;</code></pre>
</blockquote>
<p>后端是一个Pose Graph的优化。通过调整nodes和submaps之间的约束关系来优化最终的图。Constraints直觉上来感觉就是由一根根小绳子将所有的nodes给捆起来，pose adjustement就是把这些小绳子给全部接起来。这也就是所谓的Pose Graph。</p>
<blockquote>
<p>Rviz中可以对这些Constraints进行可视化，这对调试Global SLAM来说是非常方便的。</p>
<p>还可以开启<code>POSE_GRAPH.constraint_builder.log_matches</code>来看关于constraints builder的report。</p>
</blockquote>
<p>约束分为非全局约束与全局约束：</p>
<ul>
<li>非全局约束也被称作(也被称作是 inter submaps constraints)。它在一条trajectory上离得近的 nodes 之间被自动构建。直觉上来看，这些约束使得trajectory的局部结构是一致的。</li>
<li>全局约束(也被称作是loop closure constraints或者intra submaps contraints)的运行：通常是在一个新的new submap和之前的nodes之间进行搜索，当满足空间上足够的相近（被一个search window限定）以及一个极强的scan match结果。直观的来讲,相当于在两个绳子(约束)之间打一个结点使得两根绳子里的更近。</li>
</ul>
<pre><code class="hljs lua">POSE_GRAPH.constraint_builder.max_constraint_distance
POSE_GRAPH.fast_correlative_scan_matcher.linear_search_window
POSE_GRAPH.fast_correlative_scan_matcher_3d.linear_xy_search_window
POSE_GRAPH.fast_correlative_scan_matcher_3d.linear_z_search_window
POSE_GRAPH.fast_correlative_scan_matcher*.angular_search_window</code></pre>
<p>官方默认配置：</p>
<p><code>pose_graph.lua</code></p>
<pre><code class="hljs lua">POSE_GRAPH = &#123;
  ...
  constraint_builder = &#123;
    max_constraint_distance = <span class="hljs-number">15.</span>,
    ...
    fast_correlative_scan_matcher = &#123;
      linear_search_window = <span class="hljs-number">7.</span>,
      angular_search_window = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">rad</span>(<span class="hljs-number">30.</span>),
      ...
    &#125;,
    fast_correlative_scan_matcher_3d = &#123;
      ...
      linear_xy_search_window = <span class="hljs-number">5.</span>,
      linear_z_search_window = <span class="hljs-number">1.</span>,
      angular_search_window = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">rad</span>(<span class="hljs-number">15.</span>),
      ...
    &#125;,
  &#125;
  ...
&#125;</code></pre>
<blockquote>
<p>// TODO ICRA RM两台机器人，这一点可以考虑</p>
<p>Cartographer不止可以单单在单个轨迹上loop closure，还可以在多个机器人的多个轨迹上align。这个部分的文档 the parameters related to “global localization” out of the scope of this document.</p>
</blockquote>
<p>为了限制constraints的数量（也是降低计算力），Cartographer对这些node做了一个下采样，通过<code>POSE_GRAPH.constraint_builder.sampling_ratio</code>参数来控制。下采样过度会导致约束缺失以及不容易进行loop closure，下采样力度过小会导致Global SLAM的运行速度过慢以及不能实时的loop closure。</p>
<p>官方默认配置：</p>
<p><code>pose_graph.lua</code></p>
<pre><code class="hljs lua">POSE_GRAPH = &#123;
  ...
  constraint_builder = &#123;
    sampling_ratio = <span class="hljs-number">0.3</span>,
    ...
  &#125;
  ...
&#125;</code></pre>
<p>当一个node和一个submap进行constraint building的时候，通过的是一个叫做FastCorrelativeScanMatcher的机制。这个scan matcher是Cartographer的独创并且使得real-time loop closures scan matching成为可能。它引入了分支界限法（Branch and bound），可以在不同分辨率的地图网格上进行工作并且非常有效的去除误匹配。关于这个在Cartographer的论文中被详细描述了。所用的搜索树的深度是可以被控制的。</p>
<pre><code class="hljs lua">POSE_GRAPH.constraint_builder.fast_correlative_scan_matcher.branch_and_bound_depth
POSE_GRAPH.constraint_builder.fast_correlative_scan_matcher_3d.branch_and_bound_depth
POSE_GRAPH.constraint_builder.fast_correlative_scan_matcher_3d.full_resolution_depth</code></pre>
<p>官方默认配置：</p>
<p><code>pose_graph.lua</code></p>
<pre><code class="hljs lua">POSE_GRAPH = &#123;
  ...
  constraint_builder = &#123;
    max_constraint_distance = <span class="hljs-number">15.</span>,
    ...
    fast_correlative_scan_matcher = &#123;
      ...
      branch_and_bound_depth = <span class="hljs-number">7</span>,
    &#125;,
    fast_correlative_scan_matcher_3d = &#123;
      ...
      branch_and_bound_depth = <span class="hljs-number">8</span>,
      full_resolution_depth = <span class="hljs-number">3</span>,
      ...
    &#125;,
  &#125;
  ...
&#125;</code></pre>
<p>一旦FastCorrelativeScanMatcher达到一定的效果的时候（大于<code>POSE_GRAPH.constraint_builder.min_score</code>参数值），会把它再继续扔到CeresScanMatcher中来进行refine。</p>
<pre><code class="hljs lua">POSE_GRAPH.constraint_builder.min_score
POSE_GRAPH.constraint_builder.ceres_scan_matcher_3d
POSE_GRAPH.constraint_builder.ceres_scan_matcher</code></pre>
<p>官方默认配置：</p>
<p><code>pose_graph.lua</code></p>
<pre><code class="hljs lua">POSE_GRAPH = &#123;
  ...
  constraint_builder = &#123;
    ...
    min_score = <span class="hljs-number">0.55</span>,
    ...
    ceres_scan_matcher = &#123;
      occupied_space_weight = <span class="hljs-number">20.</span>,
      translation_weight = <span class="hljs-number">10.</span>,
      rotation_weight = <span class="hljs-number">1.</span>,
      ceres_solver_options = &#123;
        use_nonmonotonic_steps = <span class="hljs-literal">true</span>,
        max_num_iterations = <span class="hljs-number">10</span>,
        num_threads = <span class="hljs-number">1</span>,
      &#125;,
    &#125;,
    ceres_scan_matcher_3d = &#123;
      occupied_space_weight_0 = <span class="hljs-number">5.</span>,
      occupied_space_weight_1 = <span class="hljs-number">30.</span>,
      translation_weight = <span class="hljs-number">10.</span>,
      rotation_weight = <span class="hljs-number">1.</span>,
      only_optimize_yaw = <span class="hljs-literal">false</span>,
      ceres_solver_options = &#123;
        use_nonmonotonic_steps = <span class="hljs-literal">false</span>,
        max_num_iterations = <span class="hljs-number">10</span>,
        num_threads = <span class="hljs-number">1</span>,
      &#125;,
    &#125;,
  &#125;,
  ...
&#125;</code></pre>
<h3 id="the-optimization-problem"><a class="markdownIt-Anchor" href="#the-optimization-problem"></a> The Optimization Problem</h3>
<p>当 Cartographer 运行优化问题的时候, Cartographer会通过多个残差项来对submaps进行调整。每一项残差通过被加权的cost function来计算（和SLAM中常见的做法一样）。这些每一个cost function取自多个数据源，全局(回环)约束<code>global (loop closure) constraints</code>，非全局(scan match)的约束<code>the non-global (matcher) constraints</code>，IMU 的测量值<code>IMU acceleration and rotation measurements</code>，local SLAM 的粗略的 pose 估计<code>local SLAM rough pose estimations</code>，外部的odometry 信息或者GPS等<code>an odometry source or a fixed frame (such as a GPS system)</code>。可通过下面项来进行配置：</p>
<pre><code class="hljs lua">POSE_GRAPH.constraint_builder.loop_closure_translation_weight
POSE_GRAPH.constraint_builder.loop_closure_rotation_weight
POSE_GRAPH.matcher_translation_weight
POSE_GRAPH.matcher_rotation_weight
POSE_GRAPH.optimization_problem.*_weight
POSE_GRAPH.optimization_problem.ceres_solver_options</code></pre>
<blockquote>
<p>TODO ?</p>
<p>One can find useful information about the residuals used in the optimization problem by toggling <code>POSE_GRAPH.max_num_final_iterations</code></p>
</blockquote>
<p>官方默认配置：</p>
<p><code>pose_graph.lua</code></p>
<pre><code class="hljs lua">POSE_GRAPH = &#123;
  ...
  constraint_builder = &#123;
    ...
    loop_closure_translation_weight = <span class="hljs-number">1.1e4</span>,
    loop_closure_rotation_weight = <span class="hljs-number">1e5</span>,
    ...
  &#125;,
  ...
  matcher_translation_weight = <span class="hljs-number">5e2</span>,
  matcher_rotation_weight = <span class="hljs-number">1.6e3</span>,
  optimization_problem = &#123;
    huber_scale = <span class="hljs-number">1e1</span>,
    acceleration_weight = <span class="hljs-number">1e3</span>,
    rotation_weight = <span class="hljs-number">3e5</span>,
    local_slam_pose_translation_weight = <span class="hljs-number">1e5</span>,
    local_slam_pose_rotation_weight = <span class="hljs-number">1e5</span>,
    odometry_translation_weight = <span class="hljs-number">1e5</span>,
    odometry_rotation_weight = <span class="hljs-number">1e5</span>,
    fixed_frame_pose_translation_weight = <span class="hljs-number">1e1</span>,
    fixed_frame_pose_rotation_weight = <span class="hljs-number">1e2</span>,
    log_solver_summary = <span class="hljs-literal">false</span>,
    ceres_solver_options = &#123;
      use_nonmonotonic_steps = <span class="hljs-literal">false</span>,
      max_num_iterations = <span class="hljs-number">50</span>,
      num_threads = <span class="hljs-number">7</span>,
    &#125;,
  &#125;,
&#125;</code></pre>
<p>在代码中，各种cost function的定义文件路径：</p>
<div align="left">
    <img src="assets/Screenshot from 2019-12-07 21-31-20.png" srcset="/img/loading.gif" style="zoom:100%;" />
</div>
<p>Cartographer提供了如下的cost functions：</p>
<div align="left">
    <img src="assets/Screenshot from 2019-12-07 21-31-48.png" srcset="/img/loading.gif" style="zoom:100%;" />
</div>
<h3 id="全局优化时对于imu数据的处理"><a class="markdownIt-Anchor" href="#全局优化时对于imu数据的处理"></a> 全局优化时对于IMU数据的处理</h3>
<p>Global optimization 对 imu 的 pose 信息提供了更多的灵活性。默认的 Ceres 会优化你 IMU 和 tracking frame 之间的外参。如果你不信任你的 imu 的数据的话, Ceres’ global optimization 的结果可以被记录然后来用来优化它俩之间的外参矩阵。如果 Ceres 不能够很好的优化 IMU 的 pose (它俩之间的外参矩阵)或者你非常信任你校准的它俩之间的外参矩阵的话，可以当做常量来使用自己标定的外参矩阵。</p>
<pre><code class="hljs lua">POSE_GRAPH.optimization_problem.log_solver_summary
POSE_GRAPH.optimization_problem.use_online_imu_extrinsics_in_3d</code></pre>
<h3 id="huber-loss"><a class="markdownIt-Anchor" href="#huber-loss"></a> Huber loss</h3>
<p>在residuals中，采用Huber loss function 从而控制outliers的影响。Huber loss function的Huber scale是定的，通过下面参数指定。</p>
<pre><code class="hljs lua">POSE_GRAPH.optimization_problem.huber_scale</code></pre>
<p>这个值选的越大，潜在的outliers对系统的影响可能就越大。</p>
<p>关于Huber loss <a href="https://blog.csdn.net/qq_29981283/article/details/83042231" target="_blank" rel="noopener">博客1</a> <a href="https://blog.csdn.net/lj6052317/article/details/87885658" target="_blank" rel="noopener">博客2</a>：</p>
<p>huber loss 是一种优化平方loss的一种方式，使得loss变化没有那么大。</p>
<p><img src="assets/20190222210736618.png" srcset="/img/loading.gif" alt="img" /></p>
<p><img src="assets/20190222210820112.png" srcset="/img/loading.gif" alt="img" /></p>
<h3 id="最终的全局优化"><a class="markdownIt-Anchor" href="#最终的全局优化"></a> 最终的全局优化</h3>
<p>一旦 当 trajectory 完成后，Cartographer 经常会运行一个新的全局优化，迭代的次数通常比之前的要多得多。这样做的原因是要尽可能的去优化最终建图的效果，并且通常并没有实时性的要求。所以选择大量的迭代是正确的选择.</p>
<pre><code class="hljs lua">POSE_GRAPH.max_num_final_iterations</code></pre>
<h5 id="附-pointcloud2消息类型的数据格式"><a class="markdownIt-Anchor" href="#附-pointcloud2消息类型的数据格式"></a> 附: PointCloud2消息类型的数据格式</h5>
<p><a href="http://docs.ros.org/api/sensor_msgs/html/msg/PointCloud2.html" target="_blank" rel="noopener">官方点云数据格式</a></p>
<p><a href="https://blog.csdn.net/Fourier_Legend/article/details/83656798" target="_blank" rel="noopener">点云数据格式解释</a></p>
<p>手动解析点云数据时不可以直接解析，因为在field里是以二进制方式存储的，可以通过<a href="https://answers.ros.org/question/273182/trying-to-understand-pointcloud2-msg/" target="_blank" rel="noopener">ros包里的工具来进行解析</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/SLAM-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/">SLAM 原理与实践</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/SLAM/">SLAM</a>
                    
                      <a class="hover-with-bg" href="/tags/Robotics/">Robotics</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！<a href="https://blog.kehan.site/about">联系作者。</a></p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/12/15/Event-based-Camera-%E6%A0%87%E5%AE%9A%E5%B7%A5%E4%BD%9C%E6%95%B4%E7%90%86%E5%A4%A7%E5%85%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">论文阅读 - Event-based Camera 标定工作整理大全</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2019/11/25/VINS-Mono-%E4%B8%AD%E7%9A%84%E8%BE%B9%E7%BC%98%E5%8C%96%E6%93%8D%E4%BD%9C%E7%90%86%E8%A7%A3/">
                        <span class="hidden-mobile">VINS-Mono 中的边缘化操作理解</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Cartographer Laser-SLAM 算法流程解析与调优&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css" />
  
















</body>
</html>
